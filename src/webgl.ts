import { DEBUG } from "./autogenerated";
import * as glEnum from "./webglEnums";
import { arrayPush, assert } from "~aliasedFunctions";

export let gl: WebGL2RenderingContext;

/*
Some stats from https://web3dsurvey.com/webgl2

GL_MAX_TEXTURE_SIZE                             1024 - 100%
MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS        50048 - 99.99%

*/

const glReverseEnumLookUp = (value: any) => {
    let k = Object.getOwnPropertyNames(WebGL2RenderingContext).find(x => (WebGL2RenderingContext as any)[x] === value);
    return k || "<ENUM VALUE NOT FOUND>";
}

export const initWebgl = (canvas: HTMLCanvasElement) => {
    console.log("JS13k2024 - Debug Build - WebGL Init");

    assert(gl == null || gl == undefined);

    gl = canvas.getContext("webgl2", { alpha: false, powerPreference: "high-performance", antialias: true }) as WebGL2RenderingContext;
    if (!gl) {
        alert("Needs WebGL2");
        throw new Error();
    }

    gl.getExtension("EXT_color_buffer_float");
}


export const loadShader = (typeId: number, source: string) => {
    const shader = gl.createShader(typeId) as WebGLShader;
    const shaderPreamble = "#version 300 es\nprecision highp float;precision highp int;";
    gl.shaderSource(shader, shaderPreamble + source);
    gl.compileShader(shader);

    if (DEBUG) {
        if (!gl.getShaderParameter(shader, glEnum.COMPILE_STATUS)) {
            console.warn(`FAILED SHADER: (TYPE ${glReverseEnumLookUp(typeId)})`);
            console.warn(`ERROR LOG`, gl.getShaderInfoLog(shader));
            console.warn("============================================");
            console.warn(source);
            gl.deleteShader(shader);
            throw new Error("SHADER COMPILATION FAILED!");
        }
    }
    return shader;
}

export const createProgramWithShaders = (shaders: [WebGLShader, WebGLShader]) => {
    const shaderProgram = gl.createProgram() as WebGLProgram;
    shaders.forEach(x => gl.attachShader(shaderProgram, x));
    gl.linkProgram(shaderProgram);

    if (DEBUG) {
        if (!gl.getProgramParameter(shaderProgram, glEnum.LINK_STATUS)) {
            console.error('Unable to link the shader program: ' + gl.getProgramInfoLog(shaderProgram));
            return null;
        }
    }

    gl.validateProgram(shaderProgram);

    if (DEBUG) {
        if (!gl.getProgramParameter(shaderProgram, glEnum.LINK_STATUS)) {
            console.error('Unable to validate the shader program: ' + gl.getProgramInfoLog(shaderProgram));
            return null;
        }
    }

    shaders.forEach(x => gl.deleteShader(x));

    if (DEBUG) {
        console.log("Shader program linked");
    }

    return shaderProgram;
};

export interface WebGLShaderBundle {
    program: WebGLProgram;
    uniforms: { [index: string]: WebGLUniformLocation; };
    vertexShader: WebGLShader,
    fragmentShader: WebGLShader;
    use: () => void;
};

export const createProgram = (vsSrc: string, fsSrc: string) => {
    const vertexShader = loadShader(glEnum.VERTEX_SHADER, vsSrc) as WebGLShader;
    const fragmentShader = loadShader(glEnum.FRAGMENT_SHADER, fsSrc) as WebGLShader;
    const program = createProgramWithShaders([vertexShader, fragmentShader]) as WebGLProgram;
    const use = () => gl.useProgram(program);
    use();
    return {
        program,
        uniforms: {},
        vertexShader, fragmentShader,
        use,
    } as WebGLShaderBundle;
};

export const deleteProgram = (prog: WebGLShaderBundle) => {
    gl.deleteShader(prog.vertexShader);
    gl.deleteShader(prog.fragmentShader);
    gl.deleteProgram(prog.program);
};

export const getUniformLocation = (prog: WebGLShaderBundle, ...names: string[]) => {
    prog.use();
    for (let name of names) {
        prog.uniforms[name] = gl.getUniformLocation(prog.program, name) as WebGLUniformLocation;
    }
};

export const setUniformMatrix4fv = (prog: WebGLShaderBundle, uniformName: string, data: number[]) => {
    gl.uniformMatrix4fv(prog.uniforms[uniformName], false, new Float32Array(data));
}

export const setUniform1f = (prog: WebGLShaderBundle, uniformName: string, param: number) => {
    gl.uniform1f(prog.uniforms[uniformName], param);
};

export const setUniform2f = (prog: WebGLShaderBundle, uniformName: string, ...params: [number, number]) => {
    gl.uniform2f(prog.uniforms[uniformName], ...params);
};

export const setUniform3f = (prog: WebGLShaderBundle, uniformName: string, ...params: [number, number, number]) => {
    gl.uniform3f(prog.uniforms[uniformName], ...params);
};

export const setUniform4f = (prog: WebGLShaderBundle, uniformName: string, ...params: [number, number, number, number]) => {
    gl.uniform4f(prog.uniforms[uniformName], ...params);
};


export const setupOrderedTextureUniforms = (prog: WebGLShaderBundle, ...names: string[]) => {
    getUniformLocation(prog, ...names);
    names.forEach((x, i) => gl.uniform1i(prog.uniforms[x], i));
};


export const createTextureWithFormatAndType = (tw: number, th: number, internalFormat: number, format: number, type: number, pixels: ArrayBufferView | null) => {
    const tex = gl.createTexture() as WebGLTexture & { w: number; h: number; };
    gl.bindTexture(glEnum.TEXTURE_2D, tex);

    while (tw > 0 && th > 0) {
        gl.texImage2D(glEnum.TEXTURE_2D, 0, internalFormat, tw, th, 0, format, type, pixels);

        if (gl.getError() == glEnum.NO_ERROR) {
            break;
        }
        tw /= 2;
        th /= 2;
    }

    gl.texParameteri(glEnum.TEXTURE_2D, glEnum.TEXTURE_MIN_FILTER, glEnum.NEAREST);
    gl.texParameteri(glEnum.TEXTURE_2D, glEnum.TEXTURE_MAG_FILTER, glEnum.NEAREST);

    gl.texParameteri(glEnum.TEXTURE_2D, glEnum.TEXTURE_WRAP_S, glEnum.CLAMP_TO_EDGE);
    gl.texParameteri(glEnum.TEXTURE_2D, glEnum.TEXTURE_WRAP_T, glEnum.CLAMP_TO_EDGE);

    tex.w = tw;
    tex.h = th;
    return tex;
};


export const createTexture = (tw: number, th: number, internalFormat: number, pixels: ArrayBufferView | null) => {
    return createTextureWithFormatAndType(tw, th, internalFormat, internalFormat == glEnum.RGBA ? glEnum.RGBA : glEnum.DEPTH_COMPONENT, internalFormat == glEnum.RGBA ? glEnum.UNSIGNED_BYTE : glEnum.FLOAT, pixels);
};

export type Texture = ReturnType<typeof createTexture>;

export const createTextureArray = (tw: number, th: number, nLayers: number, internalFormat: number) => {
    const tex = gl.createTexture() as WebGLTexture;
    gl.bindTexture(glEnum.TEXTURE_2D_ARRAY, tex);

    assert(internalFormat == glEnum.RGBA8);


    const levels = Math.log2(tw) + 1;

    gl.texStorage3D(glEnum.TEXTURE_2D_ARRAY, levels, internalFormat, tw, th, nLayers);

    gl.texParameteri(glEnum.TEXTURE_2D_ARRAY, glEnum.TEXTURE_MIN_FILTER, glEnum.LINEAR_MIPMAP_LINEAR);
    gl.texParameteri(glEnum.TEXTURE_2D_ARRAY, glEnum.TEXTURE_MAG_FILTER, glEnum.LINEAR);

    gl.texParameteri(glEnum.TEXTURE_2D_ARRAY, glEnum.TEXTURE_WRAP_S, glEnum.CLAMP_TO_EDGE);
    gl.texParameteri(glEnum.TEXTURE_2D_ARRAY, glEnum.TEXTURE_WRAP_T, glEnum.CLAMP_TO_EDGE);

    return {
        tex,
        w: tw,
        h: th,
        numLayers: nLayers,
        curLayer: 0,
        internalFormat,
    };
};

export type TextureArray = ReturnType<typeof createTextureArray>;

export const createTexture3d = (w: number, h: number, d: number, filter: number, repeat?: boolean, format?: number) => {
    const tex = gl.createTexture() as WebGLTexture;
    gl.bindTexture(glEnum.TEXTURE_3D, tex);

    const levels = 1;
    format = format ?? glEnum.R16F;


    gl.texStorage3D(glEnum.TEXTURE_3D, levels, format, w, h, d);

    gl.texParameteri(glEnum.TEXTURE_3D, glEnum.TEXTURE_MIN_FILTER, filter);
    gl.texParameteri(glEnum.TEXTURE_3D, glEnum.TEXTURE_MAG_FILTER, filter);

    const repeatFlag = repeat ? glEnum.REPEAT : glEnum.CLAMP_TO_EDGE;
    gl.texParameteri(glEnum.TEXTURE_3D, glEnum.TEXTURE_WRAP_S, repeatFlag);
    gl.texParameteri(glEnum.TEXTURE_3D, glEnum.TEXTURE_WRAP_T, repeatFlag);

    return {
        tex, w, h, d,
    };
};

export type Texture3d = ReturnType<typeof createTexture3d>;


export const texture3dSubdata = (tex: Texture3d, x: number, y: number, pixels: ArrayBufferView, w?: number, h?: number, components?: number) => {
    gl.bindTexture(glEnum.TEXTURE_3D, tex.tex);
    w = w ?? tex.d;
    h = h ?? tex.d;
    components = components ?? glEnum.RED;
    gl.texSubImage3D(glEnum.TEXTURE_3D, 0, x, y, 0, w, h, tex.d, components, glEnum.FLOAT, pixels);
};

export const pushTextureArrayLayer = (tex: TextureArray, pixels: ArrayBufferView) => {
    assert(tex.curLayer < tex.numLayers, "Texture array overflow!");
    gl.bindTexture(glEnum.TEXTURE_2D_ARRAY, tex.tex);
    gl.texSubImage3D(glEnum.TEXTURE_2D_ARRAY, 0, 0, 0, tex.curLayer++, tex.w, tex.h, 1, glEnum.RGBA, glEnum.UNSIGNED_BYTE, pixels);
};

export type Framebuffer = WebGLFramebuffer & {
    w: number;
    h: number;
    colorTextures: Texture[];
    depthTexture: Texture;
};

export const resetFramebuffer = (w: number, h: number) => {
    gl.bindFramebuffer(glEnum.FRAMEBUFFER, null);
    gl.viewport(0, 0, w, h);
};

export const setFramebuffer = (fb: Framebuffer) => {
    gl.bindFramebuffer(glEnum.FRAMEBUFFER, fb);
    gl.viewport(0, 0, fb.w, fb.h);
};

export const FBAttachNone = 0;
export const FBAttachDepth = 1;
export const FBAttachRGBAU8 = 2;
export const FBAttachRGBA32F = 3;
export const FBAttachRGBA16F = 3;

export const createFramebuffer = (w: number, h: number, ...attachments: (number | Texture)[]): Framebuffer => {
    const fb = gl.createFramebuffer() as Framebuffer;
    gl.bindFramebuffer(glEnum.FRAMEBUFFER, fb);

    const colorTextures: Texture[] = [];
    let depthTexture!: Texture;
    let lastTexture!: Texture;

    for (let a of attachments) {
        if (typeof (a) == "number") {
            if (a == FBAttachNone) {
                gl.drawBuffers([glEnum.NONE]);
            } else if (a == FBAttachDepth) {
                depthTexture = createTexture(w, h, glEnum.DEPTH_COMPONENT32F, null);
                gl.framebufferTexture2D(
                    glEnum.FRAMEBUFFER, glEnum.DEPTH_ATTACHMENT, glEnum.TEXTURE_2D, depthTexture, 0);
                lastTexture = depthTexture;
            } else {
                const tex = a == FBAttachRGBAU8
                    ? createTexture(w, h, glEnum.RGBA, null)
                    : createTextureWithFormatAndType(w, h, glEnum.RGBA16F, glEnum.RGBA, glEnum.FLOAT, null);
                gl.framebufferTexture2D(glEnum.FRAMEBUFFER, glEnum.COLOR_ATTACHMENT0 + colorTextures.length, glEnum.TEXTURE_2D, tex, 0);
                arrayPush(colorTextures, tex);
                lastTexture = tex;
            }
        } else {
            gl.framebufferTexture2D(glEnum.FRAMEBUFFER, glEnum.COLOR_ATTACHMENT0 + colorTextures.length, glEnum.TEXTURE_2D, a, 0);
            arrayPush(colorTextures, a);
            lastTexture = a;
        }
    }

    fb.w = lastTexture.w;
    fb.h = lastTexture.h;
    fb.colorTextures = colorTextures;
    fb.depthTexture = depthTexture;

    return fb;
}

export const glEnable = (cap: GLenum) => {
    gl.enable(cap);
}

export const glDisable = (cap: GLenum) => {
    gl.disable(cap);
}

export const bindTextures = (target: GLenum, basis: number, ...textures: WebGLTexture[]) => {
    for (let t of textures) {
        gl.activeTexture(basis++);
        gl.bindTexture(target, t);
    };
    return basis;
};

export const freeFramebuffer = (f: Framebuffer) => {
    for (let t of f.colorTextures) {
        gl.deleteTexture(t);
    }
    if (f.depthTexture) {
        gl.deleteTexture(f.depthTexture);
    }
    gl.deleteFramebuffer(f);
}

export const createUBO = (size: number) => {
    const buffer = gl.createBuffer() as WebGLBuffer;
    gl.bindBuffer(glEnum.UNIFORM_BUFFER, buffer);
    gl.bufferData(glEnum.UNIFORM_BUFFER, size, glEnum.DYNAMIC_DRAW);
    return buffer;
};